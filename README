To run our website, go to
spork194.herokuapp.com
(enable google maps to look for your current location if it asks, and sign in with facebook).

We used Rails and Bootstrap.
Deployed to Heroku.
Dish images are on AWS.

*****HEROKU WILL CUT US OFF IN 7 DAYS BECAUSE WE ARE EXCEEDING THE NUMBER OF ROWS FOR A FREE ACCOUNT*****

--------------------------------------

We will be going through each page of the website, and pointing to the code that runs for that page.

spork/scraping: 
-One of the main issues with this website was data collection. The first problem was that we needed restaurants and menus with items to review. We looked online and found 2 good websites that aggregated menus: allmenus.com and menupages.com. The first thing we built was a scraper for each of these sites given a restaurant specific url (AllMenu_Scraper.py and MenuPages_Scraper.py). The code was written so that you could pass in a single url, and it would return some sort of formatted csv of the menu. After that, we created a script on allmenus.com that would get the ~200 restaurants in the palo alto area, with some information about them. Putting this all together, SeedTest1.py used the list of restaurants to get all menus from each of the palo alto restaurants. At this point we had plenty of data, and never finished SeedTest2.py (the end to end scraper for menupages.com).
-After getting all the menus, we were faced with the task of associating pictures with these restaurants. Our design was meant to be picture oriented, so without these pictures we would have been in trouble. We wrote "google_image_scraper.py" to get 4 images for each of the restaurants, by typing the restaurant name and "Palo Alto" into a google image search API/ajax call. This worked relatively well, although some images left something to be desired. For example, one restaurant name is "New York New York", so "New York New York Palo Alto" did not lead to any restaurant pictures. However, we did get the pictures and having 4 pictures allows for hand curation of the best image.
-We also wanted to get the pictures of all the food items. At first we were planning on manually downloading ~50 images and just showing that data, but that was boring and obviously not scalable. At this point we already had the google image scraper code, but we had a data issue. We stored the restaurant pictures locally, and then uploaded them all to github. However, the max repo size is about 1 GB, so we couldn't be uploading over 10,000 photos. Plus, that's just annoying. After receiving an email about the free AWS credits, we thought we could leverage those and use S3 as a storage medium. After some trial and error with Boto, an S3 package for python, we were able to upload images to an S3 bucket. From there it was easy enough to use the public s3 url as the location for our images.
-In general a lot of the code in /scraping was writted as 1-off scripts, so it is not as well maintained as the rest of the code base. 

spork/db:

- migrate: This folder contains all of the migration files that specifies the schema for the database. 
- final_seeds.yml file: occupies the database with real data that was scraped from the internet (~500,000 line file). 
- addPicturesScript.rb: Using the pictures that google image api retrieved, addPicturesScript.rb takes all of the .jpg files, parses each file name to get the restaurant name, queries the Restaurant database table to retrieve the id for the restaurant, and writes to the yaml file for each image to add Picture elements to the database data.
- addRatingScript.rb: Goes through each food item, retrieves the id, and writes 5 rating elements to the YAML file for each food item with random scores so that all food items have ratings.
- addRatingsToEachDishScript.rb: The database was changed to store an average rating field on each food item. This script went through each food item in the yaml file, calculated the average rating for that food item, then added the average rating as a column attribute into the yaml file.
- geoscrap.rb: After all of the addresses for the restaurants were scraped, it was necessary to occupy the database with the latitude and longitude coordinates for these addresses. geoscrap.rb was written to send HTTP requests to the Google Maps API to retrieve latitude and longitude values to write into the YAML file.
- schema.rb: auto generated by rails based on the models/migrations specified
- There are a couple other miscellaneous scripts written recently to clean up the database (remove_3_ratings, update_seeds)

spork/app/models:
- Each model specifies the types of objects that reside in the database. Many of them have field validations to ensure objects aren't saved that don't conform to certain criteria (ie. a rating must be between 1 and 5)


We will now discuss each page of the website and the associated controller, views, and javascript files. We'll discuss them as a user going through the site. The user starts at the homepage:

HOME PAGE (http://spork194.herokuapp.com):
  - When this page is accessed, we first get your location.  The main page prompts the user to allow location tracking.  We then autofill the location query in our search bar.
  - Once we have the location, we send an ajax request with the location to find the most popular results near the location and we display them using the dish partial page templates, found in app/views/shared.
  - Login: The login button is present all throughout the app.  If you try to log in, but our app has never seen you before, you get added to the users table in our database. We take note of your facebook id, which we use to render your profile picture.

From here, the user will probably enter a search term and location to arrive at the results page:

RESULTS PAGE:
- /spork/app/controllers/results_controller: The results controller handles the controller logic for the results page.  If an address was entered, it pulls the coordinates for the address using google maps. If the address entered isn't valid or no location was entered, then it will choose the user's current location as the address. The page does complex SQL queries to find all dishes whose dish name contains the search query, dish description contains the search query, the restaurant name that the dish belongs to contains the search query, and it must belong to a restaurant that is within the circular mile radius distance specified by the search result from the given address, all sorted by average rating.  A SQL query is also done to find all restaurants who have dishes that fit the above criteria, and restaurants within the specified distance.
- /spork/app/views/results/search.html.erb: The associated search view displays the dishes and restaurants organized by rating in a paginized partial.  The user can also change the max distance radius for restaurants they are searching for, which is done in ajax to prevent page refreshes.
- /spork/app/assets/javascripts/results.js: This javascript file handles all of the google map interactions. It adds all of the pin and data to the map, sizes the map based on the bounds of the pins added, and uses AJAX to retrieve the dishes and restaurants from the results_controller to display on the map upon a user change.

At this point the user can change their search query, increase the distance of the search, click on a food item to go to the associated food page, or click on a pin to go to the restaurant page. Let us go to the restaurant page from a pin:

RESTAURANT PAGE: (ex: http://spork194.herokuapp.com/restaurant/show/80)
- /spork/app/controllers/restaurant_controller: The restaurant controller handles the controller logic for the restaurant page. 
    - the controller function "show", and it's associated view in views/restaurant/show.html.erb, shows the pictures and information for a restaurant, as well as the top rated items on the menu and reviews for the items.
    - The restaurant displays basic information about the restaurant in an easy to view way.
    - It shows the top rated items in the restaurant
    - It shows every review of any food item in the restaurant

The user can click on the "Menu" button to arrive at the restaurant's menu page:
	- the controller function "menu", and it's associated view in views/restaurant/menu.html.erb, show all food items *CURRENTLY* on the menu of the restaurant. 
  
		1) One of the disadvantages of competing sites like Foodspotting is that the majority of items seen on restaurant pages are no longer on the menu due to seasonal menu changes or changes in chefs. Spork allows administrators to update what items are currently on their menu. If the user is an admin for the restaurant, then they can click "Update Menu" to be brought to their admin page).
		2) Any user can, at the bottom of the menu, click "Don't see your dish? Add it here" to add a new dish to the menu; they can also add a review as well if they wish in the same popup form. There is also error checking for empty dish names / improper (not a number or < 0) pricing if a price is put - in either or both cases, the appropriate input fields are highlighted red till clicked again, and the error emssages are told to the user as to what to fix. This form submit is handled in the controller under the function addDish
    3) The menu page also shows the average ratings for all of its foods. The average rating is updated in the model every time a new rating is added, and it is always current.

Lets say the admin user clicks "Update Menu". The administrative page is a defining feature which gives Spork a competitive advantage over other sites for restaurant and dish information to remain up to date:
- The edit function in the controller and its view displays the page with two forms. Let us look at both:
	- The RIGHT form is for updating the restaurant. The admin can change any information which will update in the database. The admin can attach multiple image files (when one image is uploaded, another input field will appear). You can also try saving changes when the Restaurant name field is blank and/or the address field is blank, and see the error checking that ensues. This calls the editRestaurant method in the controller to add the fields to the database and images to the images folder.
	- The left form is for updating the menu. The admin page can see what is currently on the menu on Spork, and what isn't; they can check off any dish they want to update and click the button at the bottom which brings them to the editSelected view. the editSelected method in the controller joins the dishes that were chosen that were on and off the menu, and prepares the dishes for the view. The view create a form of many inputs encapsulated in a table with the values of all the dishes selected. The admin can click the "Currently on Menu" header to toggle all on menu fields, or click each "false" or "true" to toggle it. They can update all other fields as well.  If any dish names are blank or prices are entered that aren't a # or less than 0 and the user tries to submit the form, the text field will highlight red until clicked on again and the form will not submit. This form calls the updateMenu function in the controller to change all of the items in the database based on the new table values.

- /spork/app/assets/javascripts/restaurant.js:  Handles a ton of logic and functionality. Form validations, setting styles based on actions, adding new fields based on user inputs, etc.

Let us go back to the menu page and click on a food item: http://spork194.herokuapp.com/restaurant/menu/80:

FOOD PAGE:
	- /spork/app/controllers/food_controller: The food controller handles the controller logic for the food page. The main food view is the view associated with the method index to get the neccessary data for the food item.  A user can add a review for the particular food item, which will display a popup to add a review and call the method in the controller addRating to add the associated pictures to the filesystem and database, and rating to the database.

PROFILE PAGE:
	- ex: http://spork194.herokuapp.com//user/profile/80
	- /spork/app/controllers/user_controller: The user controller handles the logic for the user profile page.
	    - "profile", and it's associated view in views/user/profile.html.erb, shows the user's profile picture, as well as the user's favorite dishes and all the items they user has reviewed.
    	- "login" and associated views in views/user/create.html.erb and lines 35-55 in views/layouts/application.html.erb, allows users to login using their Facebook profile, as well as allows logged in users to add reviews.
    	- "logout" clears the users's session.
	- The current user's profile picture is always on the top navigation bar so the current user can always reach his own profile easily.

PARTIAL PAGE TEMPLATES
We have a flexible set of partial page templates for both dish and restauarant results. There are partials for the individual squares as well as the pages of results as a whole. If you look near the end of the ResultsController, you will notice there are a lot of options for rendering these partials. The reason is that the partials are rendered in very different ways depending on the page requesting them. For example, the home page only shows dish results, and the partial spans the width of the page. On the other hand, the results page shows both dish and restaurant results, each taking up half the width of the page. The parameters you can change while rendering the partials include:
  -limit on the total results returned
  -the number of items per row
  -the number of rows per page (page as in the pagination, not the web page)
  -whether you want dish results only, restauarant results only, or both-
  -whether you want json to be returned in addition to the HTML (this case refers specifically to the results page, where we feed the JSON to the Google Map, but we also want a pre-rendered template that we just insert into the DOM as a whole, rather than parsing the JSON)

PAGINATION
We used the bootstrap-paginator.js plugin to simplify the pagination on our site. The native Bootstrap paginator is purely markup and has no functionality. The plugin makes setting options and callbacks easier.
There is a javascript file called init-pagination.js, which has a function that is meant to be called from other javascript files to initialize the paginators. For example, we can't initalize the paginator on the home page until the AJAX response with the partials comes in. So we call the function at that time to init the paginator. On the results page, we call it on load (since the partials are already rendered), and then again when AJAX returns new results.